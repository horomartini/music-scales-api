// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.1
// source: tuning.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { PhysicalNote, Tuning } from "./common";

export const protobufPackage = "tunings";

export interface GetTuningRequest {
  /** Required; ID of the tuning to retrieve, must be a valid id per database schema; Supports AIP-217 */
  id: string;
}

export interface GetTuningResponse {
  /** Retrieved tuning based on ID */
  tuning: Tuning | undefined;
}

export interface GetTuningsRequest {
  /** Optional; Filtering; Supports AIP-160 */
  filter: string;
  /** Optional; Ordering; Supports AIP-132 */
  orderBy: string;
  /** Optional; Paginating; Supports AIP-158 */
  pageSize: number;
  /** Optional; Conceptually treated as "page x", where x is page number */
  pageToken: string;
}

export interface GetTuningsResponse {
  /** Ordered and filtered array of items */
  tunings: Tuning[];
  /** Total number of items in database before filter, order and pagination */
  totalCount: number;
  /** Next page cursor token as per AIP-158 */
  nextPageToken: string;
  /** Total number of pages generated from given page_size in request */
  totalPages: number;
}

export interface AddTuningRequest {
  /** Required; Name of new tuning */
  name: string;
  /** Optional; ID reference to existing instrument */
  instrumentId: string;
  /** Optional; Array of two-prop objects consisting of octaves and ID references to existing notes */
  notes: PhysicalNote[];
}

export interface AddTuningResponse {
  /** Newly created tuning */
  tuning: Tuning | undefined;
}

export interface UpdateTuningRequest {
  /** Required; ID of the tuning to update; Supports AIP-217 */
  id: string;
  /** Optional; New name to overwrite old tuning with */
  name: string;
  /** Optional; New ID reference to existing instrument */
  instrumentId: string;
  /** Optional; New array of two-prop objects consisting of octaves and ID references to existing notes */
  notes: PhysicalNote[];
}

export interface UpdateTuningResponse {
  /** Updated tuning */
  tuning: Tuning | undefined;
}

export interface DeleteTuningRequest {
  /** Required; ID of the tuning to delete; Supports AIP-217 */
  id: string;
}

export interface DeleteTuningResponse {
  /** ID of the deleted tuning */
  id: string;
}

function createBaseGetTuningRequest(): GetTuningRequest {
  return { id: "" };
}

export const GetTuningRequest: MessageFns<GetTuningRequest> = {
  encode(message: GetTuningRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTuningRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTuningRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTuningRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetTuningRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTuningRequest>, I>>(base?: I): GetTuningRequest {
    return GetTuningRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTuningRequest>, I>>(object: I): GetTuningRequest {
    const message = createBaseGetTuningRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetTuningResponse(): GetTuningResponse {
  return { tuning: undefined };
}

export const GetTuningResponse: MessageFns<GetTuningResponse> = {
  encode(message: GetTuningResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tuning !== undefined) {
      Tuning.encode(message.tuning, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTuningResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTuningResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tuning = Tuning.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTuningResponse {
    return { tuning: isSet(object.tuning) ? Tuning.fromJSON(object.tuning) : undefined };
  },

  toJSON(message: GetTuningResponse): unknown {
    const obj: any = {};
    if (message.tuning !== undefined) {
      obj.tuning = Tuning.toJSON(message.tuning);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTuningResponse>, I>>(base?: I): GetTuningResponse {
    return GetTuningResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTuningResponse>, I>>(object: I): GetTuningResponse {
    const message = createBaseGetTuningResponse();
    message.tuning = (object.tuning !== undefined && object.tuning !== null)
      ? Tuning.fromPartial(object.tuning)
      : undefined;
    return message;
  },
};

function createBaseGetTuningsRequest(): GetTuningsRequest {
  return { filter: "", orderBy: "", pageSize: 0, pageToken: "" };
}

export const GetTuningsRequest: MessageFns<GetTuningsRequest> = {
  encode(message: GetTuningsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(18).string(message.orderBy);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTuningsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTuningsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTuningsRequest {
    return {
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: GetTuningsRequest): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTuningsRequest>, I>>(base?: I): GetTuningsRequest {
    return GetTuningsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTuningsRequest>, I>>(object: I): GetTuningsRequest {
    const message = createBaseGetTuningsRequest();
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetTuningsResponse(): GetTuningsResponse {
  return { tunings: [], totalCount: 0, nextPageToken: "", totalPages: 0 };
}

export const GetTuningsResponse: MessageFns<GetTuningsResponse> = {
  encode(message: GetTuningsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tunings) {
      Tuning.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTuningsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTuningsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tunings.push(Tuning.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTuningsResponse {
    return {
      tunings: globalThis.Array.isArray(object?.tunings) ? object.tunings.map((e: any) => Tuning.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: GetTuningsResponse): unknown {
    const obj: any = {};
    if (message.tunings?.length) {
      obj.tunings = message.tunings.map((e) => Tuning.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTuningsResponse>, I>>(base?: I): GetTuningsResponse {
    return GetTuningsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTuningsResponse>, I>>(object: I): GetTuningsResponse {
    const message = createBaseGetTuningsResponse();
    message.tunings = object.tunings?.map((e) => Tuning.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseAddTuningRequest(): AddTuningRequest {
  return { name: "", instrumentId: "", notes: [] };
}

export const AddTuningRequest: MessageFns<AddTuningRequest> = {
  encode(message: AddTuningRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.instrumentId !== "") {
      writer.uint32(18).string(message.instrumentId);
    }
    for (const v of message.notes) {
      PhysicalNote.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddTuningRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTuningRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.notes.push(PhysicalNote.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTuningRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      instrumentId: isSet(object.instrumentId) ? globalThis.String(object.instrumentId) : "",
      notes: globalThis.Array.isArray(object?.notes) ? object.notes.map((e: any) => PhysicalNote.fromJSON(e)) : [],
    };
  },

  toJSON(message: AddTuningRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.instrumentId !== "") {
      obj.instrumentId = message.instrumentId;
    }
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => PhysicalNote.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddTuningRequest>, I>>(base?: I): AddTuningRequest {
    return AddTuningRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddTuningRequest>, I>>(object: I): AddTuningRequest {
    const message = createBaseAddTuningRequest();
    message.name = object.name ?? "";
    message.instrumentId = object.instrumentId ?? "";
    message.notes = object.notes?.map((e) => PhysicalNote.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddTuningResponse(): AddTuningResponse {
  return { tuning: undefined };
}

export const AddTuningResponse: MessageFns<AddTuningResponse> = {
  encode(message: AddTuningResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tuning !== undefined) {
      Tuning.encode(message.tuning, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddTuningResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTuningResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tuning = Tuning.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTuningResponse {
    return { tuning: isSet(object.tuning) ? Tuning.fromJSON(object.tuning) : undefined };
  },

  toJSON(message: AddTuningResponse): unknown {
    const obj: any = {};
    if (message.tuning !== undefined) {
      obj.tuning = Tuning.toJSON(message.tuning);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddTuningResponse>, I>>(base?: I): AddTuningResponse {
    return AddTuningResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddTuningResponse>, I>>(object: I): AddTuningResponse {
    const message = createBaseAddTuningResponse();
    message.tuning = (object.tuning !== undefined && object.tuning !== null)
      ? Tuning.fromPartial(object.tuning)
      : undefined;
    return message;
  },
};

function createBaseUpdateTuningRequest(): UpdateTuningRequest {
  return { id: "", name: "", instrumentId: "", notes: [] };
}

export const UpdateTuningRequest: MessageFns<UpdateTuningRequest> = {
  encode(message: UpdateTuningRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.instrumentId !== "") {
      writer.uint32(26).string(message.instrumentId);
    }
    for (const v of message.notes) {
      PhysicalNote.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTuningRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTuningRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notes.push(PhysicalNote.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTuningRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      instrumentId: isSet(object.instrumentId) ? globalThis.String(object.instrumentId) : "",
      notes: globalThis.Array.isArray(object?.notes) ? object.notes.map((e: any) => PhysicalNote.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdateTuningRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.instrumentId !== "") {
      obj.instrumentId = message.instrumentId;
    }
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => PhysicalNote.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTuningRequest>, I>>(base?: I): UpdateTuningRequest {
    return UpdateTuningRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTuningRequest>, I>>(object: I): UpdateTuningRequest {
    const message = createBaseUpdateTuningRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.instrumentId = object.instrumentId ?? "";
    message.notes = object.notes?.map((e) => PhysicalNote.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateTuningResponse(): UpdateTuningResponse {
  return { tuning: undefined };
}

export const UpdateTuningResponse: MessageFns<UpdateTuningResponse> = {
  encode(message: UpdateTuningResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tuning !== undefined) {
      Tuning.encode(message.tuning, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTuningResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTuningResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tuning = Tuning.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTuningResponse {
    return { tuning: isSet(object.tuning) ? Tuning.fromJSON(object.tuning) : undefined };
  },

  toJSON(message: UpdateTuningResponse): unknown {
    const obj: any = {};
    if (message.tuning !== undefined) {
      obj.tuning = Tuning.toJSON(message.tuning);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTuningResponse>, I>>(base?: I): UpdateTuningResponse {
    return UpdateTuningResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTuningResponse>, I>>(object: I): UpdateTuningResponse {
    const message = createBaseUpdateTuningResponse();
    message.tuning = (object.tuning !== undefined && object.tuning !== null)
      ? Tuning.fromPartial(object.tuning)
      : undefined;
    return message;
  },
};

function createBaseDeleteTuningRequest(): DeleteTuningRequest {
  return { id: "" };
}

export const DeleteTuningRequest: MessageFns<DeleteTuningRequest> = {
  encode(message: DeleteTuningRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTuningRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTuningRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTuningRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteTuningRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTuningRequest>, I>>(base?: I): DeleteTuningRequest {
    return DeleteTuningRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTuningRequest>, I>>(object: I): DeleteTuningRequest {
    const message = createBaseDeleteTuningRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteTuningResponse(): DeleteTuningResponse {
  return { id: "" };
}

export const DeleteTuningResponse: MessageFns<DeleteTuningResponse> = {
  encode(message: DeleteTuningResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTuningResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTuningResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTuningResponse {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteTuningResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTuningResponse>, I>>(base?: I): DeleteTuningResponse {
    return DeleteTuningResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTuningResponse>, I>>(object: I): DeleteTuningResponse {
    const message = createBaseDeleteTuningResponse();
    message.id = object.id ?? "";
    return message;
  },
};

export type TuningServiceService = typeof TuningServiceService;
export const TuningServiceService = {
  getTuning: {
    path: "/tunings.TuningService/GetTuning",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTuningRequest) => Buffer.from(GetTuningRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTuningRequest.decode(value),
    responseSerialize: (value: GetTuningResponse) => Buffer.from(GetTuningResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTuningResponse.decode(value),
  },
  getTunings: {
    path: "/tunings.TuningService/GetTunings",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTuningsRequest) => Buffer.from(GetTuningsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTuningsRequest.decode(value),
    responseSerialize: (value: GetTuningsResponse) => Buffer.from(GetTuningsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTuningsResponse.decode(value),
  },
  addTuning: {
    path: "/tunings.TuningService/AddTuning",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddTuningRequest) => Buffer.from(AddTuningRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddTuningRequest.decode(value),
    responseSerialize: (value: AddTuningResponse) => Buffer.from(AddTuningResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddTuningResponse.decode(value),
  },
  updateTuning: {
    path: "/tunings.TuningService/UpdateTuning",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateTuningRequest) => Buffer.from(UpdateTuningRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateTuningRequest.decode(value),
    responseSerialize: (value: UpdateTuningResponse) => Buffer.from(UpdateTuningResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateTuningResponse.decode(value),
  },
  deleteTuning: {
    path: "/tunings.TuningService/DeleteTuning",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteTuningRequest) => Buffer.from(DeleteTuningRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteTuningRequest.decode(value),
    responseSerialize: (value: DeleteTuningResponse) => Buffer.from(DeleteTuningResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteTuningResponse.decode(value),
  },
} as const;

export interface TuningServiceServer extends UntypedServiceImplementation {
  getTuning: handleUnaryCall<GetTuningRequest, GetTuningResponse>;
  getTunings: handleUnaryCall<GetTuningsRequest, GetTuningsResponse>;
  addTuning: handleUnaryCall<AddTuningRequest, AddTuningResponse>;
  updateTuning: handleUnaryCall<UpdateTuningRequest, UpdateTuningResponse>;
  deleteTuning: handleUnaryCall<DeleteTuningRequest, DeleteTuningResponse>;
}

export interface TuningServiceClient extends Client {
  getTuning(
    request: GetTuningRequest,
    callback: (error: ServiceError | null, response: GetTuningResponse) => void,
  ): ClientUnaryCall;
  getTuning(
    request: GetTuningRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTuningResponse) => void,
  ): ClientUnaryCall;
  getTuning(
    request: GetTuningRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTuningResponse) => void,
  ): ClientUnaryCall;
  getTunings(
    request: GetTuningsRequest,
    callback: (error: ServiceError | null, response: GetTuningsResponse) => void,
  ): ClientUnaryCall;
  getTunings(
    request: GetTuningsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTuningsResponse) => void,
  ): ClientUnaryCall;
  getTunings(
    request: GetTuningsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTuningsResponse) => void,
  ): ClientUnaryCall;
  addTuning(
    request: AddTuningRequest,
    callback: (error: ServiceError | null, response: AddTuningResponse) => void,
  ): ClientUnaryCall;
  addTuning(
    request: AddTuningRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddTuningResponse) => void,
  ): ClientUnaryCall;
  addTuning(
    request: AddTuningRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddTuningResponse) => void,
  ): ClientUnaryCall;
  updateTuning(
    request: UpdateTuningRequest,
    callback: (error: ServiceError | null, response: UpdateTuningResponse) => void,
  ): ClientUnaryCall;
  updateTuning(
    request: UpdateTuningRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateTuningResponse) => void,
  ): ClientUnaryCall;
  updateTuning(
    request: UpdateTuningRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateTuningResponse) => void,
  ): ClientUnaryCall;
  deleteTuning(
    request: DeleteTuningRequest,
    callback: (error: ServiceError | null, response: DeleteTuningResponse) => void,
  ): ClientUnaryCall;
  deleteTuning(
    request: DeleteTuningRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteTuningResponse) => void,
  ): ClientUnaryCall;
  deleteTuning(
    request: DeleteTuningRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteTuningResponse) => void,
  ): ClientUnaryCall;
}

export const TuningServiceClient = makeGenericClientConstructor(
  TuningServiceService,
  "tunings.TuningService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): TuningServiceClient;
  service: typeof TuningServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
